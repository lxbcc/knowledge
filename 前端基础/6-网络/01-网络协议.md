2024-04-08
[前端面试题 - 计算机网络与浏览器相关-CSDN博客](https://blog.csdn.net/weixin_45811256/article/details/129692811)
[前端面试必备 | 计算机网络篇 - 知乎](https://zhuanlan.zhihu.com/p/656907465)
## 01-从浏览器地址栏输入url到显示页面的步骤

1. 浏览器解析输入的url，提取出其中的协议、域名和路径等信息
2. 浏览器向[[DNS]]服务器发送请求，DNS服务器通过多层查询，将该域名解析为对应的IP地址，然后将请求发送到该IP地址上，与服务器建立连接和交换数据
3. 浏览器与服务器建立TCP链接（**三次握手**）
4. 浏览器向服务器发送HTTP请求，包含请求头和请求体
5. 服务器接收并处理数据，并返回响应数据，包含状态码、响应头和响应体
6. 浏览器接收到响应数据，解析响应头和响应体，并根据状态码判断是否成功
7. 如果响应成功浏览器解析渲染页面=》浏览器便开始下载网页，HTML,CSS,JS文件后依次渲染
8. 连接结束，断开TCP连接，四次挥手

## 02-HTTP

### HTTP协议概念

**概念**：HTTP是**超文本传输协议**，是一种用于在Web上发送和接收超文本（如HTML）的**应用层协议**，定义了客户端和服务器之间交换报文的格式和方式，默认使用 **80 端口**。它使用 **TCP** 作为传输层协议，保证了数据传输的可靠性。

**特点**
1. 基于客户端-服务器模式
2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
4. 无状态：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
5. 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
6. 跨平台性：HTTP 天然具有跨平台的特性，使得开发者能够更容易地在不同操作系统和设备上实现应用请求过程

**缺点**
1. 无状态：在完成有关联性的操作时会非常麻烦。例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。
2. 明文传输
3. 不安全：
   a.通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏；  
   b.不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多； 
   c.无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染；

### HTTP的完整请求过程

发起一个 HTTP 请求之后，浏览器**首先查找缓存**，如果缓存没有命中，那么继续发起 **DNS 请求获取 IP地址**，然后利用IP地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了**重定向**的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。
![[Pasted image 20240408085446.png]]


### 请求报文和响应报文的组成

1. <mark class="hltr-cyan">请求报文</mark>

   请求行：请求方法(GET、POST) + URL + 协议版本(例如Http1.1)
   请求头部 header: 由多组参数（key-value）构成
   空行：标志着header的结束
   请求体：如果传参方法为GET，那么body为空，如果为POST那么传送的参数都在body中
   
   ![[Pasted image 20240408105826.png]]

2. <mark class="hltr-cyan">响应报文</mark>

   首行：HTTP协议的版本+响应状态码+状态码信息说明
   响应头部 header ： 由多组参数（key-value）构成
   空行：标志着header的结束。
   body：服务器返回给浏览器的响应信息，响应数据的格式是根据服务器来的，常见的响应数据格式有：text/html、application/json 等。

### http的文本传输和流传输？使用场景

1. **文本传输**：这种方式数据作为文本字符串发送，因此易于阅读、解析和处理。同时，这种方式具有一定的`可读性`，便于`诊断错误`。主要应用场景是`传输小型文本数据`，例如通过POST方法提交表单数据。由于文本类型数据通常较小，因此使用文本传更方便和高效。

2. **流传输**：这种方式将数据以<mark class="hltr-green">2进制流</mark>的方式传输，允许客户端和服务器在数据传输过程中即时处理。这一特性对于`处理大型文件、下载，二进制图像、视频音频`等需求非常实用，在数据体积大、网络环境不稳定且延迟高的情况下表现尤佳。使用流传输可以使数据更快地到达接收方，同时减少网络上的数据传输时间和额外开销。

### 常见的HTTP方法

1. GET： 要求服务器将URL定位的资源放在响应报文的数据部分，返回给客户端
2. POST：将实体提交到指定的资源，通常会造成服务器资源的修改
3. PUT：用于更新服务器上的现有资源
4. DELETE：删除服务器上的对象
5. HEAD：服务端接受到HEAD请求后只返回响应头，而不会发送响应内容
6. OPTIONS：询问支持的请求方法，用来跨域请求；预检请求
7. CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信
8. TRACE：回显服务器收到的请求，主要⽤于测试或诊断

### OPTIONS
[HTTP 之 options预请求 nginx 解决跨域 postman调试跨域问题\_http option-CSDN博客](https://blog.csdn.net/wwj256/article/details/134059091)

<mark class="hltr-yellow">1. 为什么需要OPTIONS</mark>

   w3c规范要求，对复杂请求，浏览器必须先使用options发起一个预检请求，从而获知服务器是否允许该跨域请求，服务器确认以后才能发起实际的HTTP请求，否则停止第二次正式请求。
   
<mark class="hltr-yellow">2. 什么情况下发生（以下都属于复杂请求）</mark>

   - 请求方法不是get head post
   - post 的content-type不是 application/x-www-form-urlencode,multipart/form-data,text/plain **[也就是把content-type设置成"application/json"]**
   - 请求设置了自定义的header字段: 比如业务需求，传一个字段，方面后端获取，不需要每个接口都传
  
<mark class="hltr-yellow">3. OPTIONS请求方法的主要用途有两个：</mark>
   
   - 获取服务器支持的所有HTTP请求方法；
   - 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

### GET 和 POST 区别

 1. **针对数据操作的类型不同**：GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。
 2. **参数大小不同**：GET请求在URL中传送的参数是有长度的限制，这个限制是浏览器规定的，并不是 RFC[rfc.net](http://www.rfc.net) 规定的
 3. **安全性不同**： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
 4. **浏览器回退表现不同**：GET在浏览器回退时是无害的，而POST会再次提交请求
 5. **浏览器对请求地址的处理不同**：GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置
![[Pasted image 20230826145935.png|650]]

### HTTP状态码
[HTTP 状态码完整指南 - 掘金](https://juejin.cn/post/7164270035681148942?searchId=202308261452591BDBC243BFE2933C5F9D)

**1xx Informational**
>1XX的状态码是在HTTP/1.1 中引入的，它们是信息性的状态码，是临时的，表示请求已被接受，需要继续处理。这些状态码并没有提供太多有用的信息，我们可能永远看不到1XX相关的状态码。

```
100 continue 
服务器已收到浏览器的请求标头，并且现在已准备好发送请求正文。这使得请求过程更加高效，因为它可以防止浏览器发送正文请求，即使标头已被拒绝

101 Switching Protocols 
服务器已经接受了客户端的请求，并将通过`Upgrade`消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的协议

102 Processing
服务器已经收到并正在处理请求，目前还没有响应。这样可以防止客户端超时，并假设请求丢失

103 Early hints
在服务器响应的HTTP消息之前返回一些响应头。该状态码用于允许用户代理预加载资源，同时服务器准备响应。
```

**2xx Success**
```
200 OK 
表示从客户端发来的请求在服务器端被正确处理

201 Created
服务器完成了浏览器的请求，因此创建了一个或多个新资源

202 Accepted
服务器已接受浏览器的请求，但仍在处理中，该请求最终可能会也可能不会进行响应

203 Non-authoritative Infomation
使用代理时可能会此状态码，这意味着代理服务器从源服务器收到了200状态码，但在将响应传递给浏览器之前已对其进行了修改

204 No Content
该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

205 Reset Content
服务器端成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。
```

**3xx Redirection**
```
301 Moved Permanently
永久重定向，已为目标资源分配了一个新的永久 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

302 Found
临时重定向 请求的资源被分配到了新的URL,希望用户能使用新的URI访问资源，和301相似，但是 302 代表的资源不是被永久重定向，只是临时性质的；也就是说已移动的资源对应的 URI 将来还有可能发生改变。

303 See Other
由于请求对应的资源存在着另一个URL,应使用GET方法定向获取请求资源

304 Not Modified
浏览器缓存相关。该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（`if-match`、`if-none-match`、`if-modified-since`、`if-unmodified-since`、`if-range`）中任意首部。

状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。

307 Temporary Redirect
该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是用了。307 会遵守浏览器标准，**不会从 POST 变成 GET**。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。


```

注意
> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。
>
> 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。

**4xx Client errors**

1. 400 Bad Request
   请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求
2. 401 Unauthorized
   发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息
3. 403 Forbidden
   客户端请求已被拒绝，因为客户端无权访问内容。与 401 不同，服务器知道客户端的身份，但由于他们无权查看内容，因此服务器拒绝提供正确的响应。
4. 404 Not Found
   表示在服务器上没有找到请求的资源
5. 405 Method Not Allow
   服务器识别到浏览器使用的 HTTP 请求方法，但需要使用不同的方法才能提供所需的资源。服务器应该总是允许客户端使用 GET 和 HEAD 方法进行访问。

**5xx Server Error**

1. 500 Internal Server Error
   服务器端在执行请求时发生了错误。也有可能是应用存在 bug 或某些临时的故障。
2. 501 Not Implemented
   请求无法处理，因为服务器不支持。
3. 502 Bad Gateway
   该扮演网关或代理角色的服务器从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的服务器或者代理服务器对其进行修复
4. 503 Service Unavailable
   服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

### http 常见请求头、响应头
[http请求头响应头大全\_51CTO博客\_http请求头](https://blog.51cto.com/u_10954139/4858828)
[常见的http请求头和响应头 - 知乎](https://zhuanlan.zhihu.com/p/579504784)
[常见的http请求头和响应头 - 知乎](https://zhuanlan.zhihu.com/p/579504784)
**请求头**
Accept
	告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type
	`Accept: text/html` 浏览器可以接受服务器回发的类型为 text/html。
	`Accept: */*` 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。
Accept-Charset
	浏览器告诉服务器自己能接收的字符集。
Accept-Encoding
	浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）。
Accept-Language
	`Accept-Language:zh-CN,zh;q=0.9` 浏览器申明自己接收的语言。
Host：
	发出请求的页面所在的域 主机名 + 端口号
Referer：发出请求的页面的URL
If-Modified-Since
	如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT
Referer
	浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL
Host
	客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn
User-Agent
	 客户端使用的操作系统和浏览器的名称和版本。
Cookie


在响应中，`Content-Type` 标头告诉客户端实际返回的内容的内容类型。
在请求中， (如 `POST` 或 `PUT`)，客户端告诉服务器实际发送的数据类型。


**响应头**
**Allow**：服务器支持哪些请求方法
**Content-Type**： 服务端返回的实体内容的类型
	`Content-Type：text/html;charset=UTF-8` 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。
**Content-Encoding**： 内容编码方式
Last-Modified
	WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等
**Server** 服务器的一些相关信息
**Date** 表示消息发送的时间
**Connection**： 浏览器与服务器之间连接的类型
**Content-Language**：响应内容所使用的语言
## 03-HTTPS

### 什么是HTTPS协议
**超文本传输安全协议**（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

通常，HTTP 直接和 TCP 通信。当使用 SSL 时，演变成先和 SSL 通信了。简言之，所谓HTTPS，其实就是身披 SSL 外壳的 HTTP。

![[Pasted image 20240408145235.png]]

对于浏览器来说，数字证书有两个作用：
- 通过数字证书向浏览器证明服务器的身份；
- 另一个是数字证书里面包含了服务器公钥。 

### TLS/SSL工作原理
TLS/SSL的功能实现主要依赖三类基本算法：**散列函数hash**、**对称加密**、**非对称加密**。这三类算法的作用如下：
- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商

### HTTPS加密过程
1. **客户端发起连接请求**：向服务器发起HTTPS连接请求，然后连接到服务器的**443**端口

2. **服务器证书**：服务器在响应客户端请求时，会将自己的**数字证书**发送给客户端（也就是**公钥**）。数字证书是由可信任的第三方证书颁发机构（Certficate Authorty,CA）签名的文件，用于验证服务器身份的真实性。

3. **客户端验证证书**：客户端接收到服务器的数字证书后，会验证证书的有效性。验证包括检查证书的签名是否有效、证书是否在有效期内，以及证书中的域名与实际访问的域名是否匹配等。（ 这部分工作由客户端的SSL/TLS来完成的，如果发现异常，弹出提示窗，提示证书存在的问题，否则就生成一个随机值，就是下方的 随机对称密钥 ）

4. **生成会话密钥：** 如果服务器的证书有效，客户端会生成一个成为“会话秘钥” 的 `随机对称密钥`。**该密钥将用于对后续的数据传输进行加密和解密**。

5. **用证书加密会话密钥**：客户端使用服务器的公钥对会话密钥进行加密，并将加密后的会话密钥发送给服务器。服务器使用自己的私钥对会话密钥进行解密，从而获取会话密钥。

6. **加密通信**：客户端和服务器之间的通信使用会话密钥进行对称加密。这意味着数据在传输过程中使用相同的密钥进行加密和解密，从而保证了数据的机密性。

### HTTPS绝对安全吗？
不是，可以通过在用户机器上安装假的 HTTPS 根证书来欺骗浏览器。
只要拿到系统权限，就能随意安装根证书
之前百度升级到https之后，很多劫持就是采用这种方式来干的，在操作系统安装假的根证书，然后劫持整个站点！
所以让黑客在你电脑上安装了根证书，https也会变得不安全了！


## 04-TCP UDP

### TCP
**面向连接**
**仅支持单播传输**
**面向字节流**
**可靠传输**
**提供拥塞控制**
**提供全双工通信**

![[Pasted image 20230822211545.png]]

### TCP和UDP的使用场景

- **TCP应用场景：** 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
- **UDP应用场景：** 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

### 三次握手
[一文搞懂TCP的三次握手和四次挥手-CSDN博客](https://blog.csdn.net/m0_38106923/article/details/108292454)
![[Pasted image 20240408154937.png|525]]
1. 客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；

2. 服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；

3. 客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。

### 四次挥手

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

**四次挥手​​​​​​​原理**：
1. 第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；

2. 第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；

3. 第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；

4. 第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。
![[Pasted image 20240408155121.png|550]]

